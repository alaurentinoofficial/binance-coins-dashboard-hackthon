import { Kafka } from 'kafkajs';
import { from, map, mergeAll, Observable, share } from 'rxjs';
const rxkfk = function (kafkaOptions, topicOptions, consumerOptions) {
    const kafka = new Kafka(kafkaOptions);
    function isConsumerSubscribeTopic(topicOptions) {
        return Object.hasOwnProperty.call(topicOptions, 'topic');
    }
    const topic = isConsumerSubscribeTopic(topicOptions) ? topicOptions : { topic: topicOptions };
    const batche$ = new Observable((subscriber) => {
        const consumer = kafka.consumer(consumerOptions);
        const processBatchWith = async () => {
            await consumer.connect();
            await consumer.subscribe(topic);
            await consumer.run({
                eachBatchAutoResolve: true,
                eachBatch: async (bachBlock) => {
                    subscriber.next(bachBlock);
                }
            });
        };
        processBatchWith();
        return async () => {
            await consumer.disconnect();
        };
    });
    const message$ = batche$.pipe(map((bachBlock) => from(bachBlock.batch.messages)), mergeAll(), map((msg) => {
        const msgContent = msg.value?.toString();
        if (!msgContent)
            return;
        try {
            return JSON.parse(msgContent);
        }
        catch {
            throw new Error('Could not parse message');
        }
    }));
    const message$$ = message$.pipe(share());
    return message$$;
};
export default rxkfk;
//# sourceMappingURL=fromKafkaTopic.js.map